{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\admin\\\\Documents\\\\GitHub\\\\React\\\\my_app\\\\src\\\\Components\\\\240723\\\\CounterState.js\",\n  _s = $RefreshSig$();\nimport styled from \"styled-components\";\nimport { useEffect, useState } from \"react\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst Container = styled.div`\n    width: 500px;\n    text-align: center;\n    margin: 0 auto;\n\n    h1 {\n        font-size: 4rem;\n    }\n\n    button {\n        width: 100px;\n        font-size: 2rem;\n        margin: 10px;\n    }\n`;\n_c = Container;\nexport function CounterState() {\n  _s();\n  // count 상태와 이를 변경할 함수를 useState를 통해 선언\n  // useState를 사용하면 동적인 데이터를 효율적으로 관리하고 업데이트할 수 있으며, 실시간 반영이 가능하다\n  // useState 사용하는 이유는 state 의 변화가 생기면 html도 자동으로 재렌더링해주기 때문\n  // const [state, setState] = useState(initialValue)\n  // 가상 DOM 을 사용, 실제 돔에 접근하여 조작하는 대신, 이것을 추상화시킨 자바스크립트 객체를 이용해 사용\n  // Virtual DOM (VDOM)은 UI의 이상적인 또는 “가상”적인 표현을 메모리에 저장하고\n  //    ReactDOM과 같은 라이브러리에 의해 “실제” DOM과 동기화하는 프로그래밍 개념, 이 과정을 재조정이라 함\n\n  console.log(\"CounterState start.\");\n\n  // let count = 0;\n  // 구조분해할당\n  const [count, setCount] = useState(0); // 호출될때 count 가 업데이트 됨\n\n  // 특정 이벤트를 등록하는 코드가 여기 있다면 여러번 등록이 되어 문제 발생\n  // useEffect(function, 빈배열) 사용 한번만 등록\n\n  // useEffect(function, deps)\n  // function : 실행하고자 하는 함수, deps : 배열 형태. function을 실행시킬 조건.\n  // deps에 특정값을 넣게 되면 컴포넌트가 mount 될 때, 지정한 값이 업데이트될 때 useEffect를 실행.\n\n  // 1. Component가 Mount 되었을 때(나타날 때)\n  //    useEffect(() => { console.log(\"맨 처음 렌더링될 때 한 번만 실행\"); },[]);\n  //    이벤트 함수 등록에 사용\n  // 2. Component가 Update 되었을 때(props, state 변경)\n  //    const mounted = useRef(false);\n  //    useEffect(() => {\n  //    if (!mounted.current) { mounted.current = true;\n  //    } else { console.log(name); console.log(\"업데이트 될 때마다 실행\"); }, [name]);\n  // 3. Component가 Unmount 되었을 때(사라질 때) & Update 되기 직전에\n  //    useEffect(() => { console.log(\"컴포넌트 나타남\"); console.log(name);\n  //       return () => { console.log(\"cleanUp 함수\"); }; });\n\n  // useEffect(() => {},[name]);\n  // 화면 업데이트 이후에 호출됨, 가장 마지막 호출\n  useEffect(() => {\n    console.log(\"useEffect: \" + count);\n  }, [count]); // 매개변수 1은 콜백함수, 매개변수 2는 상태 의존성 배열\n\n  function minus() {\n    // count = count - 1;\n    setCount(count - 1); // 업데이트할 값을 전달, 직접적으로 계산하거나 할당해서는 안됨\n    console.log(\"minus count: \" + count);\n  }\n  function plus() {\n    // count = count + 1;\n    setCount(count + 1); // 업데이트할 값을 전달, 직접적으로 계산하거나 할당해서는 안됨\n    console.log(\"plus count: \" + count);\n  }\n  console.log(\"CounterState end. count: \" + count);\n  useEffect(() => {\n    // 빈 의존성배열의 의미는 컴포넌트가 처음 로드\n  });\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: /*#__PURE__*/_jsxDEV(Container, {\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: count\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 82,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: minus,\n        children: \"-\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 83,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: plus,\n        children: \"+\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 84,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 9\n    }, this)\n  }, void 0, false);\n}\n_s(CounterState, \"MD2HH0EjGUMCoeKoB+fX0xWGIOA=\");\n_c2 = CounterState;\nvar _c, _c2;\n$RefreshReg$(_c, \"Container\");\n$RefreshReg$(_c2, \"CounterState\");","map":{"version":3,"names":["styled","useEffect","useState","jsxDEV","_jsxDEV","Fragment","_Fragment","Container","div","_c","CounterState","_s","console","log","count","setCount","minus","plus","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c2","$RefreshReg$"],"sources":["C:/Users/admin/Documents/GitHub/React/my_app/src/Components/240723/CounterState.js"],"sourcesContent":["import styled from \"styled-components\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\nconst Container = styled.div`\r\n    width: 500px;\r\n    text-align: center;\r\n    margin: 0 auto;\r\n\r\n    h1 {\r\n        font-size: 4rem;\r\n    }\r\n\r\n    button {\r\n        width: 100px;\r\n        font-size: 2rem;\r\n        margin: 10px;\r\n    }\r\n`;\r\n\r\nexport function CounterState() {\r\n\r\n    // count 상태와 이를 변경할 함수를 useState를 통해 선언\r\n    // useState를 사용하면 동적인 데이터를 효율적으로 관리하고 업데이트할 수 있으며, 실시간 반영이 가능하다\r\n    // useState 사용하는 이유는 state 의 변화가 생기면 html도 자동으로 재렌더링해주기 때문\r\n    // const [state, setState] = useState(initialValue)\r\n    // 가상 DOM 을 사용, 실제 돔에 접근하여 조작하는 대신, 이것을 추상화시킨 자바스크립트 객체를 이용해 사용\r\n    // Virtual DOM (VDOM)은 UI의 이상적인 또는 “가상”적인 표현을 메모리에 저장하고\r\n    //    ReactDOM과 같은 라이브러리에 의해 “실제” DOM과 동기화하는 프로그래밍 개념, 이 과정을 재조정이라 함\r\n\r\n    console.log(\"CounterState start.\");\r\n\r\n    // let count = 0;\r\n    // 구조분해할당\r\n    const [count, setCount] = useState(0); // 호출될때 count 가 업데이트 됨\r\n\r\n    // 특정 이벤트를 등록하는 코드가 여기 있다면 여러번 등록이 되어 문제 발생\r\n    // useEffect(function, 빈배열) 사용 한번만 등록\r\n\r\n    // useEffect(function, deps)\r\n    // function : 실행하고자 하는 함수, deps : 배열 형태. function을 실행시킬 조건.\r\n    // deps에 특정값을 넣게 되면 컴포넌트가 mount 될 때, 지정한 값이 업데이트될 때 useEffect를 실행.\r\n\r\n    // 1. Component가 Mount 되었을 때(나타날 때)\r\n    //    useEffect(() => { console.log(\"맨 처음 렌더링될 때 한 번만 실행\"); },[]);\r\n    //    이벤트 함수 등록에 사용\r\n    // 2. Component가 Update 되었을 때(props, state 변경)\r\n    //    const mounted = useRef(false);\r\n    //    useEffect(() => {\r\n    //    if (!mounted.current) { mounted.current = true;\r\n    //    } else { console.log(name); console.log(\"업데이트 될 때마다 실행\"); }, [name]);\r\n    // 3. Component가 Unmount 되었을 때(사라질 때) & Update 되기 직전에\r\n    //    useEffect(() => { console.log(\"컴포넌트 나타남\"); console.log(name);\r\n    //       return () => { console.log(\"cleanUp 함수\"); }; });\r\n\r\n    // useEffect(() => {},[name]);\r\n    // 화면 업데이트 이후에 호출됨, 가장 마지막 호출\r\n    useEffect(() => {\r\n        console.log(\"useEffect: \" + count);\r\n    }, [count]); // 매개변수 1은 콜백함수, 매개변수 2는 상태 의존성 배열\r\n\r\n    function minus() {\r\n        // count = count - 1;\r\n        setCount(count - 1) // 업데이트할 값을 전달, 직접적으로 계산하거나 할당해서는 안됨\r\n        console.log(\"minus count: \" + count);\r\n    }\r\n\r\n    function plus() {\r\n        // count = count + 1;\r\n        setCount(count + 1) // 업데이트할 값을 전달, 직접적으로 계산하거나 할당해서는 안됨\r\n        console.log(\"plus count: \" + count);\r\n    }\r\n\r\n    console.log(\"CounterState end. count: \" + count);\r\n\r\n    useEffect(() => {\r\n        // 빈 의존성배열의 의미는 컴포넌트가 처음 로드\r\n\r\n    })\r\n\r\n    return (<>\r\n        <Container>\r\n            <h1>{count}</h1>\r\n            <button onClick={minus}>-</button>\r\n            <button onClick={plus}>+</button>\r\n        </Container>\r\n    </>);\r\n}"],"mappings":";;AAAA,OAAOA,MAAM,MAAM,mBAAmB;AACtC,SAASC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AAE5C,MAAMC,SAAS,GAAGP,MAAM,CAACQ,GAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,EAAA,GAdIF,SAAS;AAgBf,OAAO,SAASG,YAAYA,CAAA,EAAG;EAAAC,EAAA;EAE3B;EACA;EACA;EACA;EACA;EACA;EACA;;EAEAC,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;;EAElC;EACA;EACA,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGb,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;;EAEvC;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACAD,SAAS,CAAC,MAAM;IACZW,OAAO,CAACC,GAAG,CAAC,aAAa,GAAGC,KAAK,CAAC;EACtC,CAAC,EAAE,CAACA,KAAK,CAAC,CAAC,CAAC,CAAC;;EAEb,SAASE,KAAKA,CAAA,EAAG;IACb;IACAD,QAAQ,CAACD,KAAK,GAAG,CAAC,CAAC,EAAC;IACpBF,OAAO,CAACC,GAAG,CAAC,eAAe,GAAGC,KAAK,CAAC;EACxC;EAEA,SAASG,IAAIA,CAAA,EAAG;IACZ;IACAF,QAAQ,CAACD,KAAK,GAAG,CAAC,CAAC,EAAC;IACpBF,OAAO,CAACC,GAAG,CAAC,cAAc,GAAGC,KAAK,CAAC;EACvC;EAEAF,OAAO,CAACC,GAAG,CAAC,2BAA2B,GAAGC,KAAK,CAAC;EAEhDb,SAAS,CAAC,MAAM;IACZ;EAAA,CAEH,CAAC;EAEF,oBAAQG,OAAA,CAAAE,SAAA;IAAAY,QAAA,eACJd,OAAA,CAACG,SAAS;MAAAW,QAAA,gBACNd,OAAA;QAAAc,QAAA,EAAKJ;MAAK;QAAAK,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAK,CAAC,eAChBlB,OAAA;QAAQmB,OAAO,EAAEP,KAAM;QAAAE,QAAA,EAAC;MAAC;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC,eAClClB,OAAA;QAAQmB,OAAO,EAAEN,IAAK;QAAAC,QAAA,EAAC;MAAC;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC1B;EAAC,gBACd,CAAC;AACP;AAACX,EAAA,CAnEeD,YAAY;AAAAc,GAAA,GAAZd,YAAY;AAAA,IAAAD,EAAA,EAAAe,GAAA;AAAAC,YAAA,CAAAhB,EAAA;AAAAgB,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}